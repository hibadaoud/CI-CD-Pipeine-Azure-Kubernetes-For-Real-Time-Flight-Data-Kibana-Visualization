  workflow:
      name: Real Time Fligh Dashboard Pipeline
      rules:
          - if: $CI_COMMIT_BRANCH == 'main' || $CI_COMMIT_BRANCH == "feature"
            when: always
          - if: $CI_MERGE_REQUEST_SOURCE_BRANCH_NAME == 'feature' && $CI_PIPELINE_SOURCE == 'merge_request_event'
            when: always

  stages:
    - lint
    - test
    - containerization
    - deploy
    # - containerization
    # - dev-deploy
    # - stage-deploy
    # - prod-deploy
    # - post-deploy

  include:
    - template: Jobs/SAST.gitlab-ci.yml
    - component: gitlab.com/gitlab-components/secret-detection/secret-detection@1.0
    # - template: Security/Container-Scanning.gitlab-ci.yml

  variables:
    IMAGE_VERSION: $CI_PIPELINE_ID
    GITLAB_ADVANCED_SAST_ENABLED: 'true'
    IMAGE_VERSION: 1847651316

  # Define a reusable job template for preparing Node.js environment with MongoDB.
  .prepare_nodejs_environment:
    image: node:18.18.0-alpine3.18
    cache:
      policy: pull-push
      when: on_success
      paths: 
        - backend/node_modules/
      key:
        files:
          - backend/package-lock.json
        prefix: node_modules
    before_script:
      - cd backend
      - npm install

    .prepare_deployment_environment: &kubernetes_deploy_job
      image: alpine:3.7
      dependencies: []
      before_script:
        - wget https://storage.googleapis.com/kubernetes-release/release/$(wget -q -O - https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl
        - chmod +x ./kubectl
        - mv ./kubectl /usr/bin/kubectl
        - apk add --no-cache gettext
        - envsubst -V

  sast:
    stage: .pre

  secret_detection:
    stage: .pre
    variables:
      SECRET_DETECTION_HISTORIC_SCAN: "false"
    rules:
      - if: $CI_COMMIT_BRANCH == "feature"
        when: never
      - if: $CI_COMMIT_BRANCH == "main"
        when: always

  lint-backend:
    stage: lint
    extends: .prepare_nodejs_environment
    script:
      - npx eslint "**/*.js" > ../eslint.txt || true
    artifacts:
      paths:
        - eslint.txt
      when: always


  lint-frontend:
    stage: lint
    extends: .prepare_nodejs_environment
    script:
      - npx htmlhint ../frontend/**/*.html > ../htmlhint.txt || true
      - npx stylelint ../frontend/**/*.css > ../stylelint.txt || true
    artifacts:
      paths:
        - htmlhint.txt
        - stylelint.txt

      when: always

  lint-python:
    stage: lint
    image: python:3.11-slim
    cache:
      key: ${CI_JOB_NAME}
      paths:
        - .cache/pip/
    before_script:
      - python3 -m venv python_env
      - python_env/bin/pip install --cache-dir=.cache/pip flake8
    script:
      - python_env/bin/flake8  spark/spark_stream.py > spark-lint.txt || true 
      - python_env/bin/flake8  kafka/producer_app.py > kafka-producer-lint.txt || true
      - python_env/bin/flake8  kafka/consumer.py > kafka-consumer-lint.txt || true
      - python_env/bin/flake8  elasticsearch/create_index_elastic.py > elasticsearch-lint.txt || true
    artifacts:
      paths:
        - spark-lint.txt 
        - kafka-producer-lint.txt
        - kafka-consumer-lint.txt
        - elasticsearch-lint.txt
      when: always


  unit-test-backend:
    extends: .prepare_nodejs_environment
    stage: test
    script:
      - npm run test:unit      
    artifacts:
      paths:
        - backend/tests/test-reports/jest-junit.xml
      when: always
      expire_in: 3 days
      reports:
        junit: backend/tests/test-reports/jest-junit.xml

  unit-test_kafka:
    stage: test
    image: python:3.11-slim
    cache:
      key: ${CI_JOB_NAME}
      paths:
        - .cache/pip/
    before_script:
      - python3 -m venv python_env
      - python_env/bin/pip install --cache-dir=.cache/pip requests confluent_kafka python-dotenv pytest pytest-mock requests-mock
    script:
      - python_env/bin/pytest tests/test_producer_app.py 
    # artifacts:
    #   paths:
    #     - kafka-test-results.txt
    #   when: always
  
  unit-test_spark:
    stage: test
    image: bitnami/spark:latest
    cache:
      key: ${CI_JOB_NAME}
      paths:
        - .cache/pip/
    before_script:
      - python3 -m venv python_env
      - python_env/bin/pip install --cache-dir=.cache/pip pytest
    script:
      - python_env/bin/pytest tests/test_spark_logic.py

  unit-test_elasticsearch:
    stage: test
    image: python:3.11-slim
    cache:
      key: ${CI_JOB_NAME}
      paths:
        - .cache/pip/
    before_script:
      - python3 -m venv python_env
      - python_env/bin/pip install --cache-dir=.cache/pip pytest
    script:
      - python_env/bin/pytest tests/test_create_es_index.py
    # artifacts:
    #   paths:
    #     - elasticsearch-test-results.txt
    #   when: always

  service-backend-test:
    extends: .prepare_nodejs_environment
    stage: test
    needs: 
      - unit-test-backend
    services:
      - name: mongo:latest
        alias: mongo
        pull_policy: always
    variables:
      MONGO_TEST_URI: 'mongodb://mongo:27017/auth_test_db?authSource=admin'
      MONGO_INITDB_ROOT_USERNAME: mongo
      MONGO_INITDB_ROOT_PASSWORD: $MONGO_PASSWORD
    script:
      - npm run test:service      
    artifacts:
      paths:
        - backend/tests/test-reports/jest-junit.xml
      when: always
      expire_in: 3 days
      reports:
        junit: backend/tests/test-reports/jest-junit.xml

  docker_build:
    stage: build_test_and_push
    image: docker:27.4.1
    dependencies: []
    services:
      - docker:27.4.1-dind 
    variables:
      DOCKER_HOST: tcp://docker:2376
      DOCKER_TLS_CERTDIR: "/certs"
      DOCKER_BUILDKIT: 1
      COMPOSE_DOCKER_CLI_BUILD: 1
      MONGO_INITDB_ROOT_USERNAME: mongo
      MONGO_INITDB_ROOT_PASSWORD: $MONGO_PASSWORD
      MONGO_URI: 'mongodb://mongo:27017/auth_db?authSource=admin'
      API_URL: $API_URL
      SECRET_KEY: $SECRET_KEY
    script:
      - export DOCKER_BUILDKIT=1
      - export COMPOSE_DOCKER_CLI_BUILD=1
      - docker compose build 
      - mkdir -p docker_images
      - docker save ${CI_REGISTRY_IMAGE}/flight-dash-kibana:${IMAGE_VERSION} > docker_images/flight-dash-kibana.tar
      - docker save ${CI_REGISTRY_IMAGE}/flight-dash-elasticsearch:${IMAGE_VERSION} > docker_images/flight-dash-elasticsearch.tar
      - docker save ${CI_REGISTRY_IMAGE}/flight-dash-backend:${IMAGE_VERSION} > docker_images/flight-dash-backend.tar
      - docker save ${CI_REGISTRY_IMAGE}/flight-dash-spark:${IMAGE_VERSION} > docker_images/flight-dash-spark.tar
      - docker save ${CI_REGISTRY_IMAGE}/flight-dash-frontend:${IMAGE_VERSION} > docker_images/flight-dash-frontend
    artifacts:
      paths:
        - docker_images
      when: on_success
      expire_in: 30 days
      
  docker_test:
    stage: build_test_and_push
    image: docker:27.4.1
    needs:
      - docker_build # Makes the artifact available from the previous pipeline
    services:
      - docker:27.4.1-dind 
    variables:
      DOCKER_HOST: tcp://docker:2376
      DOCKER_TLS_CERTDIR: "/certs"
      DOCKER_BUILDKIT: 1
      COMPOSE_DOCKER_CLI_BUILD: 1
      MONGO_INITDB_ROOT_USERNAME: mongo
      MONGO_INITDB_ROOT_PASSWORD: $MONGO_PASSWORD
      MONGO_URI: 'mongodb://mongo:27017/auth_db?authSource=admin'
      API_URL: $API_URL
      SECRET_KEY: $SECRET_KEY
      PORT: 3000
    cache:
      key: ${CI_JOB_NAME}
      paths:
         - .cache/pip/
    before_script:
      - apk add --no-cache python3 py3-pip curl jq
      - python3 -m venv python_env
      - python_env/bin/pip install --cache-dir=.cache/pip  requests  
    script:
      - docker load -i docker_images/flight-dash-kibana.tar
      - docker load -i docker_images/flight-dash-elasticsearch.tar
      - docker load -i docker_images/flight-dash-backend.tar
      - docker load -i docker_images/flight-dash-spark.tar
      - docker load -i docker_images/flight-dash-frontend.tar
      - docker compose up -d
      - BACKEND_API_BASE='http://docker:3000'
      - chmod +x wait-for-services.sh
      - ./wait-for-services.sh
      - docker compose push
      - RESPONSE=$(curl http://docker:9090 )
      - if echo "$RESPONSE" | grep -q "RUNNING"; then echo "The application is RUNNING."; else echo "The application is not running" && exit 1; fi 
      - RESPONSE=$(curl http://docker:8081 )
      - if echo "$RESPONSE" | grep -q "RUNNING"; then echo "The exexutor on worker-1 is RUNNING."; else echo "The exexutor on worker-1 is not running" && exit 1; fi
      - RESPONSE=$(curl http://docker:8082 )
      - if echo "$RESPONSE" | grep -q "RUNNING"; then echo "The exexutor on worker-2 is RUNNING."; else echo "The exexutor on worker-2 is not running" && exit 1; fi  
      - python_env/bin/python3 integration_test.py
      # - docker logs backend-cntr 
      - docker compose down
      
  docker_push:
    stage: build_test_and_push
    image: docker:27.4.1
    needs:
      - docker_push
      - docker_test
    services:
      - docker:27.4.1-dind 
    before_script:
      - docker login -u "$CI_REGISTRY_USER" -p "$CI_REGISTRY_PASSWORD" "$CI_REGISTRY"
    script:
      - docker load -i docker_images/flight-dash-kibana.tar
      - docker load -i docker_images/flight-dash-elasticsearch.tar
      - docker load -i docker_images/flight-dash-backend.tar
      - docker load -i docker_images/flight-dash-spark.tar
      - docker load -i docker_images/flight-dash-frontend.tar
      - docker login -u "$CI_REGISTRY_USER" -p "$CI_REGISTRY_PASSWORD" "$CI_REGISTRY"
      - docker push ${CI_REGISTRY_IMAGE}/flight-dash-kibana:${IMAGE_VERSION} 
      - docker push ${CI_REGISTRY_IMAGE}/flight-dash-elasticsearch:${IMAGE_VERSION}
      - docker push ${CI_REGISTRY_IMAGE}/flight-dash-backend:${IMAGE_VERSION}
      - docker push ${CI_REGISTRY_IMAGE}/flight-dash-spark:${IMAGE_VERSION}
      - docker push ${CI_REGISTRY_IMAGE}/flight-dash-frontend:${IMAGE_VERSION}

  k8s_deploy:
    <<: *kubernetes_deploy_job
    stage: deploy
    needs:
      - docker_push
    script:
      - export KUBECONFIG=$KUBE_CONFIG
      - kubectl version -o yaml
      - kubectl config get-contexts
      - kubectl get nodes
      - export INGRESS_IP=$(kubectl get service -n app-routing-system nginx -o jsonpath="{.status.loadBalancer.ingress[0].ip}")
      - echo $INGRESS_IP  
      - kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.10.1/cert-manager.yaml
      - sleep 30
      - kubectl get pods -n cert-manager
      - kubectl apply -f kubernetes/clusterIssuer.yaml
      - echo "Waiting for ClusterIssuer to be created..."
      - kubectl wait --for=condition=Ready clusterissuer --all --timeout=60s
      - kubectl get clusterissuer
      - kubectl describe clusterissuer letsencrypt
      - kubectl create secret generic mongo-db-creds --from-literal=MONGO_URI=$MONGO_URI --from-literal=MONGO_INITDB_ROOT_USERNAME=$MONGO_INITDB_ROOT_USERNAME --from-literal=MONGO_INITDB_ROOT_PASSWORD=$MONGO_INITDB_ROOT_PASSWORD --save-config --dry-run=client -o yaml | kubectl apply -f -
      - BACKEND_API_BASE='/api'
      - for i in kubernetes/*.yaml; do envsubst < $i | kubectl apply -f -; done
      - sleep 30
      - kubectl get certificate ingress-local-tls 
      - kubectl describe certificate ingress-local-tls   
      - kubectl get all,secret,ing
      - echo "INGRESS_URL=$(kubectl get ingress flight-dashboard-ingress -o jsonpath="{.spec.rules[0].host}")" >> app_ingress_url.env
    artifacts:
      reports:
        dotenv: app_ingress_url.env
    rules:
      - if: $CI_COMMIT_BRANCH == "feature"
        when: always
      - if: $CI_COMMIT_BRANCH == "main"
        when: never

  k8s_integration_testing:
    stage: dev-deploy
    image: alpine:3.7
    needs:
      - k8s_deploy
    before_script:
      - apk --no-cache add curl
      - apk --no-cache add jq
    script:
      - echo $INGRESS_URL
      - echo "Waiting for service to stabilize..."
      - sleep 30
      - kubectl port-forward svc/elasticsearch 9200:9200 &
      - kubectl port-forward svc/backend 3000:3000 &
      - kubectl port-forward svc/spark-master-svc 9090:8080 &
      - kubectl port-forward svc/spark-worker-svc 8081:8081 &
      - kubectl port-forward svc/spark-worker-svc 8082:8082 &
      - RESPONSE=$(curl http://localhost:9090 )
      - if echo "$RESPONSE" | grep -q "RUNNING"; then echo "The application is RUNNING."; else echo "The application is not running" && exit 1; fi 
      - RESPONSE=$(curl http://localhost:8081 )
      - if echo "$RESPONSE" | grep -q "RUNNING"; then echo "The exexutor on worker-1 is RUNNING."; else echo "The exexutor on worker-1 is not running" && exit 1; fi
      - RESPONSE=$(curl http://localhost:8082 )
      - if echo "$RESPONSE" | grep -q "RUNNING"; then echo "The exexutor on worker-2 is RUNNING."; else echo "The exexutor on worker-2 is not running" && exit 1; fi  
      - python_env/bin/python3 integration_test_prod.py
    rules:
      - if: $CI_COMMIT_BRANCH == "feature"
        when: always
      - if: $CI_COMMIT_BRANCH == "main"
        when: never
  
  